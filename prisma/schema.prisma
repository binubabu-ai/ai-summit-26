// Docjays Database Schema
// Virtual Version Control System for Documentation
// Enhanced with Knowledge Governance Layer (v2.0)

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

generator client {
  provider = "prisma-client-js"
}

// ============================================
// ENUMS - Document Governance
// ============================================

enum DocumentType {
  ARCHITECTURE // ADRs, system design docs
  API_CONTRACT // API specifications, schemas
  DOMAIN_MODEL // Business logic, domain concepts
  SECURITY // Security policies, compliance
  FEATURE_SPEC // Feature specifications
  RUNBOOK // Operational procedures
  GENERAL // Everything else
}

enum ConstraintLevel {
  HARD // MUST comply (blocks execution)
  SOFT // SHOULD comply (warns only)
  INFO // Informational (no enforcement)
}

enum ReviewSchedule {
  NEVER // No periodic review
  MONTHLY // Review every 30 days
  QUARTERLY // Review every 90 days
  BIANNUAL // Review every 180 days
  ANNUAL // Review every 365 days
}

enum ApprovalAction {
  APPROVED // Approved grounding
  REJECTED // Rejected grounding
  REQUESTED_CHANGES // Requested changes before approval
  REVIEWED // Periodic review completed
  DEPRECATED // Marked as deprecated
}

enum LinkType {
  IMPLEMENTS // Feature implements this spec
  REFERENCES // Feature references this doc
  CONSTRAINS // Doc constrains how feature is built
  DOCUMENTS // Doc documents the feature
}

enum SystemicType {
  NAMING_INCONSISTENCY // Inconsistent terminology
  VERSIONING_CONFLICT // Version mismatch
  SCOPE_OVERLAP // Overlapping responsibilities
  DEPENDENCY_CIRCULAR // Circular dependency
  ARCHITECTURE_DRIFT // Deviation from architecture
}

enum ResolutionType {
  MERGED // Conflicting parts merged
  PRIORITIZED // One version chosen
  SPLIT // Split into separate concerns
  DEPRECATED // Marked old version deprecated
  REWRITTEN // Complete rewrite
}

enum DecisionStatus {
  PROPOSED // Proposed decision
  ACCEPTED // Decision accepted
  REJECTED // Decision rejected
  DEPRECATED // Decision no longer valid
  SUPERSEDED // Replaced by another decision
}

enum DecisionSource {
  PR // Extracted from pull request
  COMMIT // Extracted from commit message
  DOCUMENT // Extracted from document
  MEETING // Captured from meeting notes
  MANUAL // Manually created
}

enum ConceptStatus {
  ACTIVE // Actively used
  DEPRECATED // No longer preferred
  AMBIGUOUS // Multiple definitions exist
  CLARIFICATION_NEEDED // Needs better definition
}

enum AlertType {
  STALE_DOCUMENT // Document not reviewed in time
  MISSING_REVIEW // Review overdue
  HARD_CONSTRAINT_VIOLATION // HARD constraint violated
  CONFLICT_DETECTED // New conflict found
  ORPHANED_DOCUMENT // No feature references
  DEPRECATED_USAGE // Using deprecated doc
  MISSING_OWNER // Document has no owner
  LOW_QUALITY // Quality score dropped
}

enum AlertSeverity {
  CRITICAL // Immediate action required
  HIGH // Address soon
  MEDIUM // Normal priority
  LOW // Informational
}

enum AlertStatus {
  ACTIVE // Alert is active
  ACKNOWLEDGED // User acknowledged
  RESOLVED // Issue resolved
  DISMISSED // User dismissed
  EXPIRED // Auto-expired
}

// User model synced with Supabase Auth
model User {
  id        String   @id // Supabase Auth UUID
  email     String   @unique
  name      String?
  avatar    String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  projects       Project[] // Projects owned by user
  members        ProjectMember[] // Projects user is a member of
  invitedMembers ProjectMember[] @relation("InvitedBy") // Members invited by this user
  versions       Version[] // Document versions created by user
  revisions      Revision[] // Revisions created by user
  auditLogs      AuditLog[] // Audit trail of user actions

  // Document Governance Relations (Phase 1)
  ownedDocuments    Document[]         @relation("DocumentOwner")
  groundedDocuments Document[]         @relation("DocumentGrounder")
  approvals         DocumentApproval[]
  createdLinks      FeatureDocLink[]

  @@map("users")
}

// A documentation project (e.g., "My API Docs", "Internal Wiki")
model Project {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique
  ownerId   String // User who created the project
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  owner     User            @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  docs      Document[]
  proposals Proposal[]
  members   ProjectMember[] // Team members with access
  apiKeys   ApiKey[] // Project-scoped API keys for MCP access

  @@index([slug])
  @@index([ownerId])
  @@map("projects")
}

// Project-scoped API keys for MCP integration
model ApiKey {
  id         String    @id @default(cuid())
  projectId  String
  name       String // User-friendly name like "Claude Desktop", "Cursor"
  key        String    @unique // The actual API key (hashed)
  keyPrefix  String // First 8 chars for display (e.g., "dj_proj_abc12345...")
  lastUsedAt DateTime?
  createdAt  DateTime  @default(now())
  expiresAt  DateTime? // Optional expiration
  isActive   Boolean   @default(true)

  // Usage tracking
  requestCount Int     @default(0)
  lastUsedFrom String? // IP address or client identifier

  // Permissions (future use)
  permissions Json? // { "read": true, "write": true, "propose": true }

  // Relations
  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId])
  @@index([key])
  @@index([isActive])
  @@index([createdAt])
  @@map("api_keys")
}

// Project team members with roles
model ProjectMember {
  id        String   @id @default(cuid())
  projectId String
  userId    String
  role      String   @default("VIEWER") // OWNER, EDITOR, VIEWER
  createdAt DateTime @default(now())

  // Invitation tracking
  invitedBy    String? // User ID who invited this member
  lastAccessAt DateTime? // Last time member accessed the project

  // Relations
  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  inviter User?   @relation("InvitedBy", fields: [invitedBy], references: [id], onDelete: SetNull)

  @@unique([projectId, userId])
  @@index([projectId])
  @@index([userId])
  @@index([invitedBy])
  @@map("project_members")
}

// A document within a project (e.g., "architecture.md", "api/auth.md")
model Document {
  id        String @id @default(cuid())
  path      String // e.g., "architecture.md" or "api/auth.md"
  projectId String
  content   String @db.Text // Current "Main" branch content (grounded truth)

  // Revision System (Hybrid VVCS)
  mainRevisionId String? @unique // Points to the current grounded revision

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Intelligence Layer Fields (AI-Native Features)
  freshnessScore     Float     @default(1.0) // 0.0-1.0 (1.0 = fresh, 0.0 = very stale)
  riskScore          Float     @default(0.0) // 0.0-1.0 (0.0 = low risk, 1.0 = high risk)
  confidenceScore    Float     @default(0.5) // 0.0-1.0 (confidence in content accuracy)
  lastVerifiedAt     DateTime? // Last manual verification by human
  lastAnalyzedAt     DateTime? // Last AI analysis run
  hasConflicts       Boolean   @default(false)
  hasMissingSections Boolean   @default(false)
  hasAmbiguity       Boolean   @default(false)

  // Grounding System Fields (Document Ingestion & Knowledge Management)
  uploadState     String    @default("ready") // "raw", "processing", "ready", "failed"
  uploadedAt      DateTime?
  processedAt     DateTime?
  processingError String?   @db.Text

  groundingState    String    @default("ungrounded") // "ungrounded", "grounded", "deprecated"
  groundedAt        DateTime?
  deprecatedAt      DateTime?
  deprecationReason String?   @db.Text

  editorialState String    @default("draft") // "draft", "review", "active", "archived"
  publishedAt    DateTime?
  archivedAt     DateTime?

  expiresAt      DateTime?
  ttlDays        Int?
  lastReviewedAt DateTime?
  nextReviewDue  DateTime?

  // Document Governance Fields (Phase 1)
  docType         DocumentType    @default(GENERAL)
  constraintLevel ConstraintLevel @default(SOFT)
  category        String? // "authentication", "database", "api"
  tags            String[]        @default([])

  // Grounding Metadata
  groundedBy     String? // User ID who grounded
  groundedReason String?        @db.Text // Why was this grounded
  owner          String? // Primary maintainer User ID
  reviewSchedule ReviewSchedule @default(NEVER)
  nextReviewDate DateTime?

  // Usage Tracking
  relatedFeatures  String[]  @default([]) // Feature slugs
  lastReferencedAt DateTime? // Last time referenced by code/AI
  referenceCount   Int       @default(0) // How many times referenced

  // Relations
  project            Project             @relation(fields: [projectId], references: [id], onDelete: Cascade)
  versions           Version[]
  revisions          Revision[] // All revisions (main, draft, proposed, etc.)
  mainRevision       Revision?           @relation("MainRevision", fields: [mainRevisionId], references: [id], onDelete: SetNull)
  conflicts          Conflict[]
  analyses           Analysis[]
  embeddings         Embedding[]
  chatMessages       ChatMessage[]
  suggestions        Suggestion[]
  modules            DocumentModule[] // Decomposed knowledge modules
  groundingSnapshots GroundingSnapshot[] // Historical grounding contexts

  // Document Governance Relations (Phase 1)
  ownerUser       User?              @relation("DocumentOwner", fields: [owner], references: [id], onDelete: SetNull)
  grounderUser    User?              @relation("DocumentGrounder", fields: [groundedBy], references: [id], onDelete: SetNull)
  approvals       DocumentApproval[]
  featureLinks    FeatureDocLink[]
  alerts          Alert[]
  decisionRecords DecisionRecord[]

  @@unique([projectId, path])
  @@index([projectId])
  @@index([path])
  @@index([mainRevisionId])
  @@index([freshnessScore])
  @@index([riskScore])
  @@index([lastAnalyzedAt])
  @@index([uploadState])
  @@index([groundingState])
  @@index([editorialState])
  @@index([expiresAt])
  @@index([nextReviewDue])
  // Phase 1 indexes
  @@index([docType])
  @@index([constraintLevel])
  @@index([category])
  @@index([owner])
  @@index([reviewSchedule])
  @@index([lastReferencedAt])
  @@index([nextReviewDate])
  @@map("documents")
}

// A proposal for changes (like a "branch" in git)
model Proposal {
  id          String   @id @default(cuid())
  title       String
  description String?  @db.Text
  branchName  String   @unique
  status      String   @default("OPEN") // OPEN, MERGED, REJECTED, ARCHIVED
  projectId   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Intelligence Fields (AI-Native Features)
  changeRationale String  @default("") @db.Text // Required for all proposals
  aiGenerated     Boolean @default(false)
  riskAssessment  Json? // AI-generated risk analysis
  conflictCheck   Json? // Pre-merge conflict detection results
  reviewComments  Json? // Structured review feedback

  // Relations
  project Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)
  changes Version[]

  @@index([projectId])
  @@index([status])
  @@index([branchName])
  @@map("proposals")
}

// Version history for documents (like commits)
model Version {
  id         String   @id @default(cuid())
  content    String   @db.Text
  docId      String
  proposalId String? // null for main branch versions
  authorId   String? // User ID or null for system/AI
  authorType String   @default("user") // "user", "ai", "system"
  createdAt  DateTime @default(now())

  // Change Metadata (Intelligence Layer)
  changeRationale String?   @db.Text // Why was this change made?
  changeType      String? // "create", "update", "delete", "merge"
  aiGenerated     Boolean   @default(false)
  reviewRequired  Boolean   @default(true)
  approvedBy      String?
  approvedAt      DateTime?

  // Relations
  document Document  @relation(fields: [docId], references: [id], onDelete: Cascade)
  proposal Proposal? @relation(fields: [proposalId], references: [id], onDelete: SetNull)
  author   User?     @relation(fields: [authorId], references: [id], onDelete: SetNull)

  @@index([docId])
  @@index([proposalId])
  @@index([authorId])
  @@index([createdAt])
  @@map("versions")
}

// Hybrid Revision System (VVCS with Grounding)
model Revision {
  id          String  @id @default(cuid())
  documentId  String
  content     String  @db.Text
  title       String // Short description of changes
  description String? @db.Text // Detailed rationale

  // Revision Status (State Machine)
  status String  @default("draft") // "draft", "proposed", "approved", "rejected", "conflicted"
  isMain Boolean @default(false) // Grounding flag: is this the source of truth?

  // Provenance Tracking
  basedOn            String? // Revision ID this was based on
  replacedRevisionId String? // If this is a rebase, which revision did it replace?
  authorId           String? // User ID or null for AI
  authorType         String  @default("ai") // "user", "ai", "system"

  // MCP Integration
  sourceClient    String? // "claude-desktop", "cursor", "windsurf", "web-ui"
  sourceSessionId String? // Client session identifier for tracking

  // Timestamps
  createdAt  DateTime  @default(now())
  proposedAt DateTime? // When status changed to "proposed"
  approvedAt DateTime? // When status changed to "approved"
  approvedBy String? // User ID who approved
  rejectedAt DateTime? // When status changed to "rejected"
  rejectedBy String? // User ID who rejected

  // Conflict Detection
  hasConflicts   Boolean @default(false)
  conflictReason String? @db.Text

  // Relations
  document Document       @relation(fields: [documentId], references: [id], onDelete: Cascade)
  author   User?          @relation(fields: [authorId], references: [id], onDelete: SetNull)
  mainFor  Document?      @relation("MainRevision") // If this is the main revision
  diffs    RevisionDiff[] // Line-by-line diffs from base

  @@index([documentId])
  @@index([status])
  @@index([isMain])
  @@index([basedOn])
  @@index([authorId])
  @@index([createdAt])
  @@index([proposedAt])
  @@map("revisions")
}

// Stores computed diffs for quick comparison
model RevisionDiff {
  id         String   @id @default(cuid())
  revisionId String
  diffType   String // "line", "word", "character"
  diffData   Json // Structured diff output from diff engine
  stats      Json // { linesAdded, linesRemoved, linesChanged }
  createdAt  DateTime @default(now())

  // Relations
  revision Revision @relation(fields: [revisionId], references: [id], onDelete: Cascade)

  @@unique([revisionId, diffType])
  @@index([revisionId])
  @@map("revision_diffs")
}

// Intelligence Layer Models
// Add these to the end of schema.prisma

// Detected conflicts between documents or within a document
model Conflict {
  id                  String    @id @default(cuid())
  documentId          String
  conflictType        String // "contradiction", "duplicate", "inconsistency", "ambiguity"
  severity            String // "critical", "high", "medium", "low"
  description         String    @db.Text
  location            Json // { line: number, column: number, text: string }
  conflictingDocId    String? // If conflict is with another doc
  conflictingLocation Json? // Location in conflicting doc
  status              String    @default("open") // "open", "acknowledged", "resolved", "ignored"
  detectedBy          String // "ai", "rule", "user"
  detectedAt          DateTime  @default(now())
  resolvedAt          DateTime?
  resolvedBy          String?
  resolvedComment     String?   @db.Text

  // Relations
  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@index([status])
  @@index([severity])
  @@index([conflictType])
  @@index([detectedAt])
  @@map("conflicts")
}

// AI analysis results for documents
model Analysis {
  id              String   @id @default(cuid())
  documentId      String
  analysisType    String // "freshness", "completeness", "ambiguity", "risk", "semantic"
  result          Json // Detailed analysis results
  score           Float // 0.0-1.0 score for this analysis type
  recommendations Json? // Suggested improvements
  analyzedAt      DateTime @default(now())
  llmModel        String // "claude-3-opus-20240229", "gpt-4-turbo"
  llmCost         Float? // Cost in USD for this analysis
  tokenCount      Int? // Total tokens used

  // Relations
  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@index([analysisType])
  @@index([analyzedAt])
  @@index([score])
  @@map("analyses")
}

// Vector embeddings for semantic search
model Embedding {
  id         String   @id @default(cuid())
  documentId String
  chunkIndex Int // Which chunk of the document (0, 1, 2, ...)
  chunkText  String   @db.Text
  embedding  String   @db.Text // Stored as JSON array for now
  // TODO: Use pgvector extension for production: Unsupported("vector(1536)")
  createdAt  DateTime @default(now())

  // Metadata
  model      String @default("text-embedding-3-small") // Embedding model used
  dimensions Int    @default(1536)

  // Relations
  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@unique([documentId, chunkIndex])
  @@index([documentId])
  @@map("embeddings")
}

// Comprehensive audit log for all actions
model AuditLog {
  id         String   @id @default(cuid())
  entityType String // "document", "proposal", "project", "user"
  entityId   String
  action     String // "create", "update", "delete", "approve", "reject", "analyze"
  actorId    String? // User ID or null for system/AI
  actorType  String // "user", "ai", "system"
  changes    Json // What changed (before/after)
  metadata   Json? // Additional context (IP, user agent, etc.)
  createdAt  DateTime @default(now())

  // Relations
  actor User? @relation(fields: [actorId], references: [id], onDelete: SetNull)

  @@index([entityType, entityId])
  @@index([actorId])
  @@index([createdAt])
  @@index([action])
  @@map("audit_logs")
}

// AI Chat System

// Chat messages between user and AI about a document
model ChatMessage {
  id          String   @id @default(cuid())
  documentId  String
  role        String // "user" | "assistant"
  content     String   @db.Text
  suggestions Json? // Array of suggestion IDs if AI generated suggestions
  createdAt   DateTime @default(now())

  // Relations
  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@index([createdAt])
  @@map("chat_messages")
}

// AI-generated suggestions for document improvements
model Suggestion {
  id            String    @id @default(cuid())
  documentId    String
  chatMessageId String? // Optional: which chat message generated this
  type          String // "rewrite", "addition", "deletion", "style", "clarity"
  title         String
  description   String    @db.Text
  originalText  String    @db.Text
  suggestedText String    @db.Text
  reasoning     String    @db.Text // Why AI suggests this change
  confidence    Float     @default(0.8) // 0.0-1.0
  status        String    @default("pending") // "pending", "applied", "rejected", "dismissed"
  appliedAt     DateTime?
  rejectedAt    DateTime?
  createdAt     DateTime  @default(now())

  // Relations
  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@index([status])
  @@index([createdAt])
  @@map("suggestions")
}

// Track AI usage and costs
model AiUsage {
  id           String   @id @default(cuid())
  userId       String?
  projectId    String?
  documentId   String?
  operation    String // "chat", "suggestion", "audit", "conflict_detection"
  model        String // "claude-opus-4-5", "claude-haiku", "claude-sonnet"
  inputTokens  Int
  outputTokens Int
  cost         Float // USD
  latency      Int? // milliseconds
  success      Boolean  @default(true)
  errorMessage String?  @db.Text
  createdAt    DateTime @default(now())

  @@index([userId])
  @@index([projectId])
  @@index([documentId])
  @@index([operation])
  @@index([createdAt])
  @@map("ai_usage")
}

// Audit System - AI-powered quality analysis at multiple levels
model Audit {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // Polymorphic - can be dashboard, project, or document
  auditType String // 'dashboard' | 'project' | 'document'
  targetId  String? // null for dashboard, project/document ID otherwise

  userId String

  // Scores (0-100)
  healthScore      Int
  consistencyScore Int?
  freshnessScore   Int?
  qualityScore     Int?

  // Findings (JSON array of AuditFinding objects)
  findings Json // Array of detailed findings with severity, category, etc.

  // Metadata
  duration Int // milliseconds
  aiModel  String // e.g., "gemini-2.5-pro"
  cost     Float // USD

  @@index([auditType])
  @@index([targetId])
  @@index([userId])
  @@index([createdAt])
  @@map("audits")
}

// ============================================
// GROUNDING SYSTEM MODELS
// Document Ingestion & Knowledge Management
// ============================================

// Logical modules/sections within a document
model DocumentModule {
  id         String @id @default(cuid())
  documentId String

  // Module Identity
  moduleKey   String // Unique identifier within document (e.g., "installation", "api-reference")
  title       String
  description String? @db.Text
  order       Int     @default(0) // Display order within document

  // Content
  content     String @db.Text
  contentHash String // Hash for change detection

  // Module Location
  startLine    Int? // Line number where module starts
  endLine      Int? // Line number where module ends
  headingLevel Int? // If derived from heading (1-6)

  // Grounding Status (Module-Level)
  isGrounded      Boolean   @default(false)
  groundedAt      DateTime?
  groundingSource String? // "manual", "ai", "import"
  confidenceScore Float     @default(0.5) // 0.0-1.0

  // Module Metadata
  moduleType String @default("section") // "section", "code-block", "table", "definition"
  tags       Json? // ["api", "getting-started"]

  // Dependencies
  dependsOn String[] @default([]) // Array of moduleKeys this depends on

  // Phase 1 Enhancements
  category     String? // "api", "security", "business-logic"
  moduleTags   String[] @default([]) // Array of tags (migrating from Json)
  entities     String[] @default([]) // Extracted entities
  concepts     String[] @default([]) // Domain concepts
  dependencies String[] @default([]) // External dependencies

  // Quality Metrics
  qualityScore Float @default(0.5) // 0.0-1.0
  clarityScore Float @default(0.5) // 0.0-1.0

  // Timestamps
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  lastGroundedAt DateTime?

  // Relations
  document         Document                 @relation(fields: [documentId], references: [id], onDelete: Cascade)
  conflicts        ModuleConflict[]
  groundingHistory ModuleGroundingHistory[]

  @@unique([documentId, moduleKey])
  @@index([documentId])
  @@index([isGrounded])
  @@index([moduleType])
  @@index([groundedAt])
  @@index([category])
  @@map("document_modules")
}

// Module-specific conflicts (extends Conflict model)
model ModuleConflict {
  id       String @id @default(cuid())
  moduleId String

  // Conflict Details
  conflictType String // "content", "scope", "version", "dependency"
  severity     String // "critical", "high", "medium", "low"
  description  String @db.Text

  // Conflicting Entity
  conflictingModuleId String? // If conflict with another module
  conflictingDocId    String? // If conflict with whole document
  conflictingLocation Json? // Precise location info

  // Resolution
  status         String    @default("open") // "open", "acknowledged", "resolved", "ignored"
  detectedBy     String // "ai", "rule", "user"
  detectedAt     DateTime  @default(now())
  resolvedAt     DateTime?
  resolvedBy     String? // User ID
  resolutionNote String?   @db.Text

  // Phase 1 Enhancements
  affectedFeatures String[]        @default([]) // Feature slugs
  systemicType     SystemicType? // If this is a pattern
  resolutionType   ResolutionType?
  resolutionDiff   Json? // What changed to resolve

  // Relations
  module DocumentModule @relation(fields: [moduleId], references: [id], onDelete: Cascade)

  @@index([moduleId])
  @@index([status])
  @@index([severity])
  @@index([conflictType])
  @@index([systemicType])
  @@index([resolutionType])
  @@map("module_conflicts")
}

// Project-scoped grounding context that MCP agents query
model GroundingSnapshot {
  id         String  @id @default(cuid())
  projectId  String
  documentId String? // Optional: can be project-wide or doc-specific

  // Snapshot Identity
  snapshotName String // e.g., "v1.0-release", "2026-01-stable"
  description  String? @db.Text

  // Grounding Data
  groundingContext Json // Complete grounded state at this point in time
  // Structure: {
  //   documents: [{ path, content, modules, metadata }],
  //   relationships: [{ from, to, type }],
  //   metadata: { createdBy, reason, tags }
  // }

  // Scope
  scope           String  @default("project") // "project", "document", "module"
  scopeIdentifier String? // ID of scope entity

  // Versioning
  version  String // Semantic version or timestamp-based
  isActive Boolean @default(true) // Current active snapshot

  // Metadata
  createdAt DateTime  @default(now())
  createdBy String? // User ID
  expiresAt DateTime? // When snapshot becomes invalid

  // Statistics
  documentCount Int @default(0)
  moduleCount   Int @default(0)
  totalSize     Int @default(0) // Bytes

  // Relations
  document Document? @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([projectId])
  @@index([documentId])
  @@index([isActive])
  @@index([version])
  @@index([createdAt])
  @@map("grounding_snapshots")
}

// Track when and why modules were grounded/ungrounded
model ModuleGroundingHistory {
  id       String @id @default(cuid())
  moduleId String

  // Grounding Event
  action        String // "grounded", "ungrounded", "updated", "verified"
  previousState String? // Previous grounding state
  newState      String // New grounding state

  // Context
  reason      String  @db.Text // Why this change happened
  source      String // "manual", "ai-analysis", "code-sync", "expiry"
  triggeredBy String? // User ID or system component

  // Content Snapshot
  contentBefore String? @db.Text
  contentAfter  String  @db.Text
  diffSummary   Json? // { linesAdded, linesRemoved, linesChanged }

  // Metadata
  confidenceScore Float? // Confidence at time of grounding
  metadata        Json? // Additional context

  // Timestamp
  occurredAt DateTime @default(now())

  // Relations
  module DocumentModule @relation(fields: [moduleId], references: [id], onDelete: Cascade)

  @@index([moduleId])
  @@index([action])
  @@index([occurredAt])
  @@map("module_grounding_history")
}

// Queue for processing uploaded documents
model DocumentProcessingJob {
  id         String @id @default(cuid())
  documentId String

  // Job Details
  jobType  String // "parse", "decompose", "analyze", "ground"
  priority Int    @default(5) // 1-10, higher = more urgent
  status   String @default("pending") // "pending", "processing", "completed", "failed"

  // Processing
  startedAt      DateTime?
  completedAt    DateTime?
  processingTime Int? // Milliseconds

  // Results
  result     Json? // Processing results
  error      String? @db.Text
  retryCount Int     @default(0)
  maxRetries Int     @default(3)

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([documentId])
  @@index([status])
  @@index([priority])
  @@index([createdAt])
  @@map("document_processing_jobs")
}

// ============================================
// PHASE 1: DOCUMENT GOVERNANCE MODELS
// ============================================

// Document approval workflow tracking
model DocumentApproval {
  id         String @id @default(cuid())
  documentId String

  // Approval Details
  approver String // User ID
  action   ApprovalAction
  comment  String?        @db.Text
  metadata Json? // { reason, tags, etc. }

  // Timestamps
  createdAt DateTime @default(now())

  // Relations
  document     Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  approverUser User     @relation(fields: [approver], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@index([approver])
  @@index([action])
  @@index([createdAt])
  @@map("document_approvals")
}

// Bidirectional feature-document relationships
model FeatureDocLink {
  id        String @id @default(cuid())
  projectId String

  // Link Details
  featureSlug String // e.g., "user-export"
  documentId  String
  linkType    LinkType

  // Metadata
  reason         String?   @db.Text
  createdBy      String? // User ID
  createdAt      DateTime  @default(now())
  lastVerifiedAt DateTime?

  // Relations
  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  creator  User?    @relation(fields: [createdBy], references: [id], onDelete: SetNull)

  @@unique([featureSlug, documentId, linkType])
  @@index([featureSlug])
  @@index([documentId])
  @@index([projectId])
  @@index([linkType])
  @@map("feature_doc_links")
}

// Architectural and technical decision registry
model DecisionRecord {
  id        String @id @default(cuid())
  projectId String

  // Decision Details
  title        String
  description  String @db.Text
  context      String @db.Text // Why this decision was needed
  decision     String @db.Text // What was decided
  consequences String @db.Text // Expected impact

  // Classification
  decisionType String // "architectural", "technical", "process"
  status       DecisionStatus @default(PROPOSED)
  source       DecisionSource

  // Provenance
  sourceUrl     String? // PR URL, commit SHA, doc path
  extractedFrom String? // "PR #123", "commit abc123", "doc: arch.md"
  extractedAt   DateTime @default(now())
  extractedBy   String? // "ai", "manual", User ID

  // Grounding
  documentId       String? // If grounded to a document
  suggestedDocPath String? // AI suggestion for where to ground

  // Relationships
  supersedes       String[] @default([]) // Decision IDs
  supersededBy     String? // Decision ID
  relatedDecisions String[] @default([]) // Decision IDs

  // Metadata
  tags               String[] @default([])
  affectedComponents String[] @default([])
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  // Relations
  document Document? @relation(fields: [documentId], references: [id], onDelete: SetNull)

  @@index([projectId])
  @@index([status])
  @@index([source])
  @@index([decisionType])
  @@index([extractedAt])
  @@map("decision_records")
}

// Domain concept registry
model ConceptRegistry {
  id        String @id @default(cuid())
  projectId String

  // Concept Details
  term       String // "API Key", "Grounding", "Revision"
  definition String   @db.Text
  aliases    String[] @default([]) // Alternative terms

  // Classification
  category String? // "technical", "business", "domain"
  domain   String? // "authentication", "versioning"

  // Provenance
  firstSeenIn      String? // Document path or module ID
  definitionSource String? // Where definition came from
  extractedAt      DateTime @default(now())

  // Status
  status     ConceptStatus @default(ACTIVE)
  confidence Float         @default(0.8) // AI confidence

  // Relationships
  relatedConcepts String[] @default([]) // Concept IDs
  usedInDocuments String[] @default([]) // Document IDs

  // Metadata
  examples   Json? // Usage examples
  references Json? // External references
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([projectId, term])
  @@index([projectId])
  @@index([category])
  @@index([status])
  @@index([term])
  @@map("concept_registry")
}

// Knowledge governance alerts
model Alert {
  id        String @id @default(cuid())
  projectId String

  // Alert Target
  documentId String? // If doc-specific
  moduleId   String? // If module-specific

  // Alert Details
  type     AlertType
  severity AlertSeverity
  title    String
  message  String        @db.Text
  metadata Json? // Additional context

  // Status
  status         AlertStatus @default(ACTIVE)
  acknowledgedBy String? // User ID
  acknowledgedAt DateTime?
  resolvedBy     String? // User ID
  resolvedAt     DateTime?
  resolutionNote String?     @db.Text

  // Timestamps
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  expiresAt DateTime? // Auto-resolve after this

  // Relations
  document Document? @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([projectId])
  @@index([documentId])
  @@index([type])
  @@index([severity])
  @@index([status])
  @@index([createdAt])
  @@map("alerts")
}
