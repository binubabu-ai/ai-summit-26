// Docjays Database Schema
// Virtual Version Control System for Documentation

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

generator client {
  provider = "prisma-client-js"
}

// User model synced with Supabase Auth
model User {
  id        String   @id // Supabase Auth UUID
  email     String   @unique
  name      String?
  avatar    String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  projects   Project[] // Projects owned by user
  members    ProjectMember[] // Projects user is a member of
  invitedMembers ProjectMember[] @relation("InvitedBy") // Members invited by this user
  versions   Version[] // Document versions created by user
  revisions  Revision[] // Revisions created by user
  auditLogs  AuditLog[] // Audit trail of user actions

  @@map("users")
}

// A documentation project (e.g., "My API Docs", "Internal Wiki")
model Project {
  id        String     @id @default(cuid())
  name      String
  slug      String     @unique
  ownerId   String     // User who created the project
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  // Relations
  owner     User       @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  docs      Document[]
  proposals Proposal[]
  members   ProjectMember[] // Team members with access
  apiKeys   ApiKey[]   // Project-scoped API keys for MCP access

  @@index([slug])
  @@index([ownerId])
  @@map("projects")
}

// Project-scoped API keys for MCP integration
model ApiKey {
  id          String    @id @default(cuid())
  projectId   String
  name        String    // User-friendly name like "Claude Desktop", "Cursor"
  key         String    @unique // The actual API key (hashed)
  keyPrefix   String    // First 8 chars for display (e.g., "dj_proj_abc12345...")
  lastUsedAt  DateTime?
  createdAt   DateTime  @default(now())
  expiresAt   DateTime? // Optional expiration
  isActive    Boolean   @default(true)

  // Usage tracking
  requestCount Int      @default(0)
  lastUsedFrom String?  // IP address or client identifier

  // Permissions (future use)
  permissions  Json?    // { "read": true, "write": true, "propose": true }

  // Relations
  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId])
  @@index([key])
  @@index([isActive])
  @@index([createdAt])
  @@map("api_keys")
}

// Project team members with roles
model ProjectMember {
  id        String   @id @default(cuid())
  projectId String
  userId    String
  role      String   @default("VIEWER") // OWNER, EDITOR, VIEWER
  createdAt DateTime @default(now())

  // Invitation tracking
  invitedBy    String?   // User ID who invited this member
  lastAccessAt DateTime? // Last time member accessed the project

  // Relations
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  inviter   User?   @relation("InvitedBy", fields: [invitedBy], references: [id], onDelete: SetNull)

  @@unique([projectId, userId])
  @@index([projectId])
  @@index([userId])
  @@index([invitedBy])
  @@map("project_members")
}

// A document within a project (e.g., "architecture.md", "api/auth.md")
model Document {
  id        String    @id @default(cuid())
  path      String    // e.g., "architecture.md" or "api/auth.md"
  projectId String
  content   String    @db.Text  // Current "Main" branch content (grounded truth)

  // Revision System (Hybrid VVCS)
  mainRevisionId String?   @unique // Points to the current grounded revision

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  // Intelligence Layer Fields (AI-Native Features)
  freshnessScore        Float     @default(1.0)      // 0.0-1.0 (1.0 = fresh, 0.0 = very stale)
  riskScore             Float     @default(0.0)      // 0.0-1.0 (0.0 = low risk, 1.0 = high risk)
  confidenceScore       Float     @default(0.5)      // 0.0-1.0 (confidence in content accuracy)
  lastVerifiedAt        DateTime? // Last manual verification by human
  lastAnalyzedAt        DateTime? // Last AI analysis run
  hasConflicts          Boolean   @default(false)
  hasMissingSections    Boolean   @default(false)
  hasAmbiguity          Boolean   @default(false)

  // Relations
  project   Project     @relation(fields: [projectId], references: [id], onDelete: Cascade)
  versions  Version[]
  revisions Revision[]  // All revisions (main, draft, proposed, etc.)
  mainRevision Revision? @relation("MainRevision", fields: [mainRevisionId], references: [id], onDelete: SetNull)
  conflicts Conflict[]
  analyses  Analysis[]
  embeddings Embedding[]
  chatMessages ChatMessage[]
  suggestions Suggestion[]

  @@unique([projectId, path])
  @@index([projectId])
  @@index([path])
  @@index([mainRevisionId])
  @@index([freshnessScore])
  @@index([riskScore])
  @@index([lastAnalyzedAt])
  @@map("documents")
}

// A proposal for changes (like a "branch" in git)
model Proposal {
  id          String    @id @default(cuid())
  title       String
  description String?   @db.Text
  branchName  String    @unique
  status      String    @default("OPEN")  // OPEN, MERGED, REJECTED, ARCHIVED
  projectId   String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Intelligence Fields (AI-Native Features)
  changeRationale       String    @default("") @db.Text  // Required for all proposals
  aiGenerated           Boolean   @default(false)
  riskAssessment        Json?     // AI-generated risk analysis
  conflictCheck         Json?     // Pre-merge conflict detection results
  reviewComments        Json?     // Structured review feedback

  // Relations
  project     Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)
  changes     Version[]

  @@index([projectId])
  @@index([status])
  @@index([branchName])
  @@map("proposals")
}

// Version history for documents (like commits)
model Version {
  id         String    @id @default(cuid())
  content    String    @db.Text
  docId      String
  proposalId String?   // null for main branch versions
  authorId   String?   // User ID or null for system/AI
  authorType String    @default("user") // "user", "ai", "system"
  createdAt  DateTime  @default(now())

  // Change Metadata (Intelligence Layer)
  changeRationale       String?   @db.Text  // Why was this change made?
  changeType            String?   // "create", "update", "delete", "merge"
  aiGenerated           Boolean   @default(false)
  reviewRequired        Boolean   @default(true)
  approvedBy            String?
  approvedAt            DateTime?

  // Relations
  document   Document  @relation(fields: [docId], references: [id], onDelete: Cascade)
  proposal   Proposal? @relation(fields: [proposalId], references: [id], onDelete: SetNull)
  author     User?     @relation(fields: [authorId], references: [id], onDelete: SetNull)

  @@index([docId])
  @@index([proposalId])
  @@index([authorId])
  @@index([createdAt])
  @@map("versions")
}

// Hybrid Revision System (VVCS with Grounding)
model Revision {
  id         String    @id @default(cuid())
  documentId String
  content    String    @db.Text
  title      String    // Short description of changes
  description String?  @db.Text // Detailed rationale

  // Revision Status (State Machine)
  status     String    @default("draft")  // "draft", "proposed", "approved", "rejected", "conflicted"
  isMain     Boolean   @default(false)    // Grounding flag: is this the source of truth?

  // Provenance Tracking
  basedOn    String?   // Revision ID this was based on
  replacedRevisionId String? // If this is a rebase, which revision did it replace?
  authorId   String?   // User ID or null for AI
  authorType String    @default("ai") // "user", "ai", "system"

  // MCP Integration
  sourceClient String?  // "claude-desktop", "cursor", "windsurf", "web-ui"
  sourceSessionId String? // Client session identifier for tracking

  // Timestamps
  createdAt  DateTime  @default(now())
  proposedAt DateTime? // When status changed to "proposed"
  approvedAt DateTime? // When status changed to "approved"
  approvedBy String?   // User ID who approved
  rejectedAt DateTime? // When status changed to "rejected"
  rejectedBy String?   // User ID who rejected

  // Conflict Detection
  hasConflicts Boolean  @default(false)
  conflictReason String? @db.Text

  // Relations
  document   Document  @relation(fields: [documentId], references: [id], onDelete: Cascade)
  author     User?     @relation(fields: [authorId], references: [id], onDelete: SetNull)
  mainFor    Document? @relation("MainRevision") // If this is the main revision
  diffs      RevisionDiff[] // Line-by-line diffs from base

  @@index([documentId])
  @@index([status])
  @@index([isMain])
  @@index([basedOn])
  @@index([authorId])
  @@index([createdAt])
  @@index([proposedAt])
  @@map("revisions")
}

// Stores computed diffs for quick comparison
model RevisionDiff {
  id         String   @id @default(cuid())
  revisionId String
  diffType   String   // "line", "word", "character"
  diffData   Json     // Structured diff output from diff engine
  stats      Json     // { linesAdded, linesRemoved, linesChanged }
  createdAt  DateTime @default(now())

  // Relations
  revision   Revision @relation(fields: [revisionId], references: [id], onDelete: Cascade)

  @@unique([revisionId, diffType])
  @@index([revisionId])
  @@map("revision_diffs")
}

// Intelligence Layer Models
// Add these to the end of schema.prisma

// Detected conflicts between documents or within a document
model Conflict {
  id                    String    @id @default(cuid())
  documentId            String
  conflictType          String    // "contradiction", "duplicate", "inconsistency", "ambiguity"
  severity              String    // "critical", "high", "medium", "low"
  description           String    @db.Text
  location              Json      // { line: number, column: number, text: string }
  conflictingDocId      String?   // If conflict is with another doc
  conflictingLocation   Json?     // Location in conflicting doc
  status                String    @default("open") // "open", "acknowledged", "resolved", "ignored"
  detectedBy            String    // "ai", "rule", "user"
  detectedAt            DateTime  @default(now())
  resolvedAt            DateTime?
  resolvedBy            String?
  resolvedComment       String?   @db.Text

  // Relations
  document              Document  @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@index([status])
  @@index([severity])
  @@index([conflictType])
  @@index([detectedAt])
  @@map("conflicts")
}

// AI analysis results for documents
model Analysis {
  id                    String    @id @default(cuid())
  documentId            String
  analysisType          String    // "freshness", "completeness", "ambiguity", "risk", "semantic"
  result                Json      // Detailed analysis results
  score                 Float     // 0.0-1.0 score for this analysis type
  recommendations       Json?     // Suggested improvements
  analyzedAt            DateTime  @default(now())
  llmModel              String    // "claude-3-opus-20240229", "gpt-4-turbo"
  llmCost               Float?    // Cost in USD for this analysis
  tokenCount            Int?      // Total tokens used

  // Relations
  document              Document  @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@index([analysisType])
  @@index([analyzedAt])
  @@index([score])
  @@map("analyses")
}

// Vector embeddings for semantic search
model Embedding {
  id                    String    @id @default(cuid())
  documentId            String
  chunkIndex            Int       // Which chunk of the document (0, 1, 2, ...)
  chunkText             String    @db.Text
  embedding             String    @db.Text  // Stored as JSON array for now
  // TODO: Use pgvector extension for production: Unsupported("vector(1536)")
  createdAt             DateTime  @default(now())

  // Metadata
  model                 String    @default("text-embedding-3-small") // Embedding model used
  dimensions            Int       @default(1536)

  // Relations
  document              Document  @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@unique([documentId, chunkIndex])
  @@index([documentId])
  @@map("embeddings")
}

// Comprehensive audit log for all actions
model AuditLog {
  id                    String    @id @default(cuid())
  entityType            String    // "document", "proposal", "project", "user"
  entityId              String
  action                String    // "create", "update", "delete", "approve", "reject", "analyze"
  actorId               String?   // User ID or null for system/AI
  actorType             String    // "user", "ai", "system"
  changes               Json      // What changed (before/after)
  metadata              Json?     // Additional context (IP, user agent, etc.)
  createdAt             DateTime  @default(now())

  // Relations
  actor                 User?     @relation(fields: [actorId], references: [id], onDelete: SetNull)

  @@index([entityType, entityId])
  @@index([actorId])
  @@index([createdAt])
  @@index([action])
  @@map("audit_logs")
}

// AI Chat System

// Chat messages between user and AI about a document
model ChatMessage {
  id          String    @id @default(cuid())
  documentId  String
  role        String    // "user" | "assistant"
  content     String    @db.Text
  suggestions Json?     // Array of suggestion IDs if AI generated suggestions
  createdAt   DateTime  @default(now())

  // Relations
  document    Document  @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@index([createdAt])
  @@map("chat_messages")
}

// AI-generated suggestions for document improvements
model Suggestion {
  id            String    @id @default(cuid())
  documentId    String
  chatMessageId String?   // Optional: which chat message generated this
  type          String    // "rewrite", "addition", "deletion", "style", "clarity"
  title         String
  description   String    @db.Text
  originalText  String    @db.Text
  suggestedText String    @db.Text
  reasoning     String    @db.Text    // Why AI suggests this change
  confidence    Float     @default(0.8) // 0.0-1.0
  status        String    @default("pending") // "pending", "applied", "rejected", "dismissed"
  appliedAt     DateTime?
  rejectedAt    DateTime?
  createdAt     DateTime  @default(now())

  // Relations
  document      Document  @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@index([status])
  @@index([createdAt])
  @@map("suggestions")
}

// Track AI usage and costs
model AiUsage {
  id            String   @id @default(cuid())
  userId        String?
  projectId     String?
  documentId    String?
  operation     String   // "chat", "suggestion", "audit", "conflict_detection"
  model         String   // "claude-opus-4-5", "claude-haiku", "claude-sonnet"
  inputTokens   Int
  outputTokens  Int
  cost          Float    // USD
  latency       Int?     // milliseconds
  success       Boolean  @default(true)
  errorMessage  String?  @db.Text
  createdAt     DateTime @default(now())

  @@index([userId])
  @@index([projectId])
  @@index([documentId])
  @@index([operation])
  @@index([createdAt])
  @@map("ai_usage")
}

// Audit System - AI-powered quality analysis at multiple levels
model Audit {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // Polymorphic - can be dashboard, project, or document
  auditType String   // 'dashboard' | 'project' | 'document'
  targetId  String?  // null for dashboard, project/document ID otherwise

  userId    String

  // Scores (0-100)
  healthScore       Int
  consistencyScore  Int?
  freshnessScore    Int?
  qualityScore      Int?

  // Findings (JSON array of AuditFinding objects)
  findings   Json     // Array of detailed findings with severity, category, etc.

  // Metadata
  duration   Int      // milliseconds
  aiModel    String   // e.g., "gemini-2.5-pro"
  cost       Float    // USD

  @@index([auditType])
  @@index([targetId])
  @@index([userId])
  @@index([createdAt])
  @@map("audits")
}
